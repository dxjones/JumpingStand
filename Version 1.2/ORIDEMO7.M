function oridemo(stim,NOISE,coarse,training)% oridemo.m (djones, version 1.2, 22feb07)%% Revisions:% 1.2 22feb07	- added support for 10-bit clut%				- hide cursor during experiment%				- display signal value as percentage%				- edges of circular mask are now anti-aliased%				- added explicit "steps_per_octave" variable%				- allow "step" variable to go negative%% 1.1 19jun03	- fixed grey lookup table problem%				- added parameters for screen dimensions and viewing distance%				- added calculations for viewing angle and spatial frequency of stimulus% 1.0 17jun03	- original version% - - - - -% Demonstration of Local Orientation Noise Stimulus%% There are 2 versions of this demo:%% oridemo(1);%	This displays a simple example in a MATLAB figure%% oridemo(2);%	This uses PsychToolbox routines to display the stimulus.%	... use arrow keys to change signal level UP or DOWN%   ... use arrow keys to move signal to LEFT or RIGHT side%   ... hit RETURN to quit the demo%% Check argumentsif stim < 1 | stim > 2	fprintf('oridemo:  stim parameter must be 0 or 1\n');	return;endif NOISE < 0 | NOISE > 1	fprintf('oridemo:  NOISE parameter must be 0 or 1\n');endif coarse < 0 | coarse > 1	fprintf('oridemo:  coarse parameter should be 0 or 1\n');end% Parameters									range			(default)background = 128;	% background grey level,	0   .. 255		(128)contrast = 0.95;	% contrast,					0.0 .. 1.0		(1)signal = 1.0;		% orientation signal,		0.0 .. 1.0		(0.9)block = 9;			% block size, in pixels,	1   .. 10		(4)					% ... make "block" bigger for coarser patterndiameter = 0.8;		% diameter of circle,		0.1 .. 1.0		(0.8)					% ... diameter is fraction of half-width of screen					DONALD = 0;if DONALD	screen_width_cm = 32.5;			% Donald's screen width in centimetres (32.5)	screen_width_pixels = 1024;		% Donald's screen width in pixels (1024)	screen_height_pixels = 758;	if coarse		block = 9;	else		block = 4;	endelse	screen_width_cm	= 48;			% Kathy's screen width in centimetres (48)	screen_width_pixels = 2304;		% Kathy's screen width in pixels (2304)	screen_height_pixels = 1440;	if coarse		block = 13;	else		block = 6;	endendviewdist_cm = 57;	% viewing distance in centimetressteps_per_octave = 8;			%step = 4 * steps_per_octave;%% NOISE = 0;			% 1 = NOISE, 0 = GRATINGgamma_exp = 1.4;	% 1.730;gamma_min = 0.025;		% 0.131;% simply display stimulus in MATLAB figureif stim == 1	n = 100;	mask = circular_mask(n, diameter*n);	img1 = local_ori_stim(n,contrast,signal);	img1 = background*(1-mask) + img1.*mask;	img2 = local_ori_stim(n,contrast,0);	img2 = background*(1-mask) + img2.*mask;	grey = repmat((0:255)'/255,1,3);	% grey ramp lookup table	figure(1);	imagesc([img1, img2]), colormap(grey), axis image;		%%	period = signal * 0.33 * diameter * n;	img1 = grating_stim(n,contrast,period);	img1 = background*(1-mask) + img1.*mask;	img2 = grating_stim(n,0,period);	img2 = background*(1-mask) + img2.*mask;		figure(2);	imagesc([img1, img2]), colormap(grey), axis image;	% display stimulus using PsychToolbox routineselseif stim == 2	w = SCREEN(0,'OpenWindow',background);	bits = ScreenDacBits(0);	grey = round((0:255) * (2^bits - 1) / 255);	grey = gamma_corrected_ramp(gamma_exp,gamma_min,bits);	grey = repmat(grey',1,3);		% grey ramp lookup table	LoadClut(w,grey);	viewdist_cm = SCREEN(w,'Dialog','Type a value for viewing distance in centimetres', viewdist_cm);% 	if NOISE% 		block=SCREEN(w,'Dialog','Type a value for block size in pixels', block);% 	end	HideCursor;		% Create a 'Rect' on screen where the stimulus will be displayed.	% The stimulus will be expanded (by a factor of "block") to fill the 'Rect'	% The 'Rect' is centered on the screen.	res = SCREEN(0,'Resolution');	if res.width ~= screen_width_pixels		fprintf('warning: PsychToolbox says screen resolution is  %d x %d pixels\n', res.width, res.height);		fprintf('warning: but screen resolution is supposed to be %d x %d pixels\n\n', screen_width_pixels, screen_height_pixels);	end	n = min(res.width/2,res.height);	if NOISE		n = floor(n/block);		rect = ScaleRect([0 0 2*n n], block,block);		stimulus_width_pixels = block*floor(diameter*n);	else		rect = [0 0 2*n n];		stimulus_width_pixels = floor(diameter*n);	end	rect = CenterRect(rect, SCREEN(w,'Rect'));	mask = circular_mask(n, floor(diameter*n));	background_mask = background * (1 - mask);	% print out the stimulus dimensions		fprintf('Stimulus Viewing Parameters:\n');	fprintf('n = %d, block = %d, stimulus diameter = %g pixels\n', ...		n,block,stimulus_width_pixels);	fprintf('check viewing angle calculation: 1 cm @ 57 cm = %5.2f degrees (should be about 1 degree)\n', ...		viewingangle(1,57));	for d = [43, 60, 90]		angle = viewingangle((stimulus_width_pixels/screen_width_pixels)*screen_width_cm,d);		spatfreq = (n/2)/angle;		fprintf('viewing distance = %d, diameter = %5.2f degrees, spatial frequency = %6.3f cycles/degree\n', ...		d, angle, spatfreq);	end		side = 1;			% 1 = left, 2 = right	KeyLeft = KbName('left');	KeyRight = KbName('right');	KeyUp = KbName('up');	KeyDown = KbName('down');	KeyPageUp = KbName('PageUp');	KeyPageDown = KbName('PageDown');	KeyReturn = KbName('return');	SCREEN(w,'TextFont','Courier');	SCREEN(w,'TextSize',12);	while 1		if NOISE			img1 = local_ori_stim(n,contrast,signal);			if training				img2 = local_ori_stim(n,0,0);			else				img2 = local_ori_stim(n,contrast,0);			end		else			period = signal * 0.33 * diameter * n;			img1 = grating_stim(n,contrast,period);			img2 = grating_stim(n,0,4);			%% img2 = grating_stim(n,contrast,4);		end		img1 = background_mask + img1.*mask;		img2 = background_mask + img2.*mask;				if side == 1			stimulus = [img1, img2];			loc = 'Left ';		else			stimulus = [img2, img1];			loc = 'Right';		end			SCREEN(w,'FillRect',background);		SCREEN(w,'PutImage',stimulus,rect);		if NOISE			msg = sprintf('%s, signal = %6.2f percent', loc,signal*100);		else			spatfreq = 1/viewingangle(period*screen_width_cm/screen_width_pixels, 57.0);			msg = sprintf('%s, period = %.2f pixels = %.2f cm, spat freq = %.3f cyc/deg', ...				loc, period, period * screen_width_cm / screen_width_pixels, spatfreq);		end		SCREEN(w,'DrawText',msg,20,20,255);			FlushEvents('KeyDown');		t = KbWait;					% wait for a key press			[ KeyIsDown, t, KeyCode ] = KbCheck;		if KeyCode(KeyLeft)			side = 1;		elseif KeyCode(KeyRight);			side = 2;		elseif KeyCode(KeyUp)			step = step+2;			if step >= 64				step=64;			end			signal = 0.01*(6.25*(2.^(step/steps_per_octave)));		elseif KeyCode(KeyDown)			step=step-1;			if NOISE & step <= 0				step=0;			end			signal = 0.01*(6.25*(2.^(step/steps_per_octave)));		elseif KeyCode(KeyPageUp)			step = step + steps_per_octave;			if step >= 64				step = 64;			end			signal = 0.01*(6.25*(2.^(step/steps_per_octave)));		elseif KeyCode(KeyPageDown)			step = step - steps_per_octave;			if NOISE & step <= 0				step=0;			end			signal = 0.01*(6.25*(2.^(step/steps_per_octave)));		elseif KeyCode(KeyReturn)			break;		end		while Kbcheck; end			% wait until key is released	end		SCREEN('CloseAll');	ShowCursor;else	fprintf('oridemo: stim must be 1 or 2\n');endreturn% viewingangle% ... calculates viewing angle of stimulus% ... given stimulus width in centimetres% ... and viewing distance in centimetresfunction angle = viewingangle(width_cm,viewdist_cm);angle = 2*(180/pi)*atan2(width_cm/2, viewdist_cm);return% circular_mask% ... creates n x n image% ... with pixels inside a circle set to 1% ... and pixels outside the circle set to 0function mask = circular_mask(n,diameter);% mask = repmat(((1:n)-(n/2)).^ 2, n,1); % mask = (mask + mask') < (diameter/2)^2;mask = repmat(((1:n)-((1+n)/2)).^ 2, n,1); mask = max(0, min(1, (((diameter+1)/2) - sqrt(mask + mask'))*(1/2) ));return% local_ori_stim% ... creates n x n image% ... containing vertical orientation stimulus% ... the strength of the function stimulus = local_ori_stim(n,contrast,signal);stimulus = zeros(n,n);oldpixel = 128 + 255*contrast*(rand(1,n)-0.5);for i = 1:n	change = rand(1,n) > signal;	newpixel = 128 + 255*contrast*(rand(1,n)-0.5);	oldpixel = change .* newpixel + (1-change) .* oldpixel;	stimulus(i,:) = oldpixel;endreturn% grating_stim% ... creates n x n image% ... containing vertical grating% ...function stimulus = grating_stim(n,contrast,period)wave = square_wave(n,period);stimulus = 128 + 127 * contrast * repmat(wave, n,1);% stimulus = stimulus';returnfunction wave = sine_wave(n,period)wave = sin(2*pi*(rand + (1:n)/period));returnfunction wave = square_wave(n,period)s = sign(sine_wave(4*n,4*period));wave = zeros(1,n);for i = 1:n	wave(i) = sum(s((i-1)*4+(1:4)))/4;endreturn% gamma_corrected_ramp% ...function g = gamma_corrected_ramp(gamma_exp, gamma_min, bits)g = zeros(1,256);for i = 0:255	g(i+1) = ((i/255) ^ (1/gamma_exp) * (1 - gamma_min) + gamma_min) * (2^bits - 1);end