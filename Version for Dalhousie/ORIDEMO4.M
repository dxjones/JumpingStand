function oridemo(version)% oridemo.m (djones, version 1.1, 19jun03)%% Revisions:% 1.1 19jun03	- fixed grey lookup table problem%				- added parameters for screen dimensions and viewing distance%				- added calculations for viewing angle and spatial frequency of stimulus% 1.0 17jun03	- original version% - - - - -% Demonstration of Local Orientation Noise Stimulus%% There are 2 versions of this demo:%% oridemo(1);%	This displays a simple example in a MATLAB figure%% oridemo(2);%	This uses PsychToolbox routines to display the stimulus.%	... use arrow keys to change signal level UP or DOWN%   ... use arrow keys to move signal to LEFT or RIGHT side%   ... hit RETURN to quit the demo%% Parameters									range			(default)background = 128;	% background grey level,	0   .. 255		(128)contrast = 1;		% contrast,					0.0 .. 1.0		(1)signal = 1.0;		% orientation signal,		0.0 .. 1.0		(0.9)block = 9;			% block size, in pixels,	1   .. 10		(4)					% ... make "block" bigger for coarser patterndiameter = 0.8;		% diameter of circle,		0.1 .. 1.0		(0.8)					% ... diameter is fraction of half-width of screenscreen_width_cm	= 32.5;			% Donald's screen width in centimetresscreen_width_pixels = 1024;		% Donald's screen width in pixelsstep=32;            % Use step to calculate decrease in stimulus. Chosen so that there are 8                    %steps per octave. Lowest stimulsu would be .615  JAH									% simply display stimulus in MATLAB figureif version == 1	n = 50;	mask = circular_mask(n, diameter*n);	img1 = local_ori_stim(n,contrast,signal);	img1 = background*(1-mask) + img1.*mask;	img2 = local_ori_stim(n,contrast,0);	img2 = background*(1-mask) + img2.*mask;	grey = repmat((0:255)'/255,1,3);	% grey ramp lookup table	figure(1);	imagesc([img1, img2]), colormap(grey), axis image;% display stimulus using PsychToolbox routineselseif version == 2	w = SCREEN(0,'OpenWindow',background);	grey = repmat((0:255)',1,3);		% grey ramp lookup table	LoadClut(w,grey);	 block=SCREEN(w,'Dialog','Type a value for block size in pixels',block);			% Create a 'Rect' on screen where the stimulus will be displayed.	% The stimulus will be expanded (by a factor of "block") to fill the 'Rect'	% The 'Rect' is centered on the screen.	res = SCREEN(0,'Resolution');	if res.width ~= screen_width_pixels		fprintf('warning: PsychToolbox says screen width is %d pixels\n',res.width);		fprintf('warning: but Donald''s screen is supposed to be %d pixels\n',screen_width_pixels);	end	n = min(res.width/2,res.height);	n = floor(n/block);	rect = ScaleRect([ 0 0 2*n n], block,block);	rect = CenterRect(rect, SCREEN(w,'Rect'));	mask = circular_mask(n, floor(diameter*n));		% print out the stimulus dimensions		fprintf('Stimulus Viewing Parameters:\n');	stimulus_width_pixels = block*floor(diameter*n);	fprintf('n = %d, block = %d, stimulus diameter = %g pixels\n', ...		n,block,stimulus_width_pixels);	fprintf('check viewing angle calculation: 1 cm @ 57 cm = %5.2f degrees (should be about 1 degree)\n', ...		viewingangle(1,57));	for d = [43, 60, 90]		angle = viewingangle((stimulus_width_pixels/screen_width_pixels)*screen_width_cm,d);		spatfreq = (n/2)/angle;		fprintf('viewing distance = %d, diameter = %5.2f degrees, spatial frequency = %5.2f cycles/degree\n', ...		d, angle, spatfreq);	end		side = 1;			% 1 = left, 2 = right	KeyLeft = KbName('left');	KeyRight = KbName('right');	KeyUp = KbName('up');	KeyDown = KbName('down');	KeyReturn = KbName('return');	SCREEN(w,'TextFont','Courier');	SCREEN(w,'TextSize',12);	while 1		img1 = local_ori_stim(n,contrast,signal);		img1 = background*(1-mask) + img1.*mask;		img2 = local_ori_stim(n,contrast,0);		img2 = background*(1-mask) + img2.*mask;				if side == 1			stimulus = [img1, img2];			loc = 'Left ';		else			stimulus = [img2, img1];			loc = 'Right';		end			SCREEN(w,'FillRect',background);		SCREEN(w,'PutImage',stimulus,rect);		msg = sprintf('%s, signal = 0.%03d', loc,floor(signal*1000));		SCREEN(w,'DrawText',msg,20,20,255);			FlushEvents('KeyDown');		t = KbWait;					% wait for a key press			[ KeyIsDown, t, KeyCode ] = KbCheck;		if KeyCode(KeyLeft)			side = 1;		elseif KeyCode(KeyRight);			side = 2;		elseif KeyCode(KeyUp)			step = step+2;			if step >31				step=32;			end						signal = 0.01*(6.25*(2.^(step*.125)));			%signal = signal * 0.75 + 0.25		elseif KeyCode(KeyDown)			step=step-1;			if step == 0				step=1;			end						signal = 0.01*(6.25*(2.^(step*.125)));			%signal = signal * 0.75		elseif KeyCode(KeyReturn)			break;		end		while Kbcheck; end			% wait until key is released	end		SCREEN('CloseAll');else	fprintf('oridemo: version must be 1 or 2\n');endreturn% viewingangle% ... calculates viewing angle of stimulus% ... given stimulus width in centimetres% ... and viewing distance in centimetresfunction angle = viewingangle(width_cm,viewdist_cm);angle = 2*(180/pi)*atan2(width_cm/2, viewdist_cm);return% circular_mask% ... creates n x n image% ... with pixels inside a circle set to 1% ... and pixels outside the circle set to 0function mask = circular_mask(n,diameter);mask = repmat(((1:n)-(n/2)).^ 2, n,1); mask = (mask + mask') < (diameter/2)^2; return% local_ori_stim% ... creates n x n image% ... containing vertical orientation stimulus% ... the strength of the function stimulus = local_ori_stim(n,contrast,signal);stimulus = zeros(n,n);oldpixel = 128 + 255*contrast*(rand(1,n)-0.5);for i = 1:n	change = rand(1,n) > signal;	newpixel = 128 + 255*contrast*(rand(1,n)-0.5);	oldpixel = change .* newpixel + (1-change) .* oldpixel;	stimulus(i,:) = oldpixel;endreturn